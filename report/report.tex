\documentclass[12pt, a4paper]{article}

\usepackage{amsmath}
\usepackage{array}
\usepackage[portuguese]{babel}
\usepackage{cite}
\usepackage{float}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{setspace}

\chardef\_=`_

\title{
    \vspace*{\fill}
    \textbf{
        Inteligência Artificial -- Trabalho Prático  \\
        \large Distribuição de alimentos durante uma catástrofe natural
    }
}

\author{
    \begin{tabular}{lc}
        Ana Carolina Penha Cerqueira       & A104188 \\
        Humberto Gil Azevedo Sampaio Gomes & A104348 \\
        João Pedro de Vasconcelos Torres   & A95748  \\
        José António Fernandes Alves Lopes & A104541 \\
        José Rodrigo Ferreira Matos        & A100612 \\
    \end{tabular}
}

\date{3 de janeiro de 2025 \vspace*{\fill}}

\begin{document}

\onehalfspacing
\setlength{\parskip}{\baselineskip}
\setlength{\parindent}{0pt}
\def\arraystretch{1.5}

\begin{titlepage}
    \maketitle
\end{titlepage}

\pagenumbering{gobble}
\pagebreak
\pagenumbering{arabic}

\section{Algoritmos de procura}

Foram implementados diversos algoritmos de procura, para poderem ser comparados em aspetos de
qualidade da solução gerada e de desempenho computacional. Nesta secção, procura-se enumerar os
algoritmos implementados e descrever algumas das otimizações desenvolvidas.

\subsection{Procura em profundidade}

Este algoritmo foi implementado com algumas diferenças em relação à sua implementação
\emph{standard}. Em primeiro lugar, é armazenado um conjunto de nós visitados, que é utilizado para
garantir que o algoritmo termina, mesmo em grafos com ciclos. De seguida, o algoritmo também foi
implementado iterativamente, e não recursivamente. Devido ao grande tamanho de uma \emph{frame} da
\emph{stack} em Python, o limite de chamadas recursivas é bastante baixo, pelo que a implementação
iterativa se provou necessária para caminhos longos. Por último, o algoritmo não expande nós que
ultrapassem o limite de combustível do veículo a realizar a procura, diminuindo o número de nós
visitados quando não existe um caminho que o veículo seja capaz de realizar.

\subsection{Procura iterativa}

Este algoritmo, através de chamadas sucessivas ao algoritmo de procura em profundidade (com uma
profundidade máxima definida), encontra o caminho entre dois nós com o menor número de saltos. No
entanto, o algoritmo de procura em profundidade descrito anteriormente não pode ser utilizado para
uma procura iterativa. O uso de um conjunto para registar os nós visitados e evitar ciclos faz com
que, após \emph{back tracking}, alguns caminhos possíveis não sejam considerados, uma vez que
envolvem nós já visitados. Logo, a verificação de ciclos na procura em profundidade limitada é feita
através da consulta do caminho até ao nó atual (e se a sua expansão não causará um ciclo)
\cite{aima}. Esta verificação mais lenta e o maior número de nós visitados (é possível que o mesmo
nó seja visitado várias vezes) fazem com que este algoritmo exija um tempo de processamento muito
superior aos restantes, pelo que não será considerado para os testes realizados.

\subsection{Procura em largura}

Este algoritmo encontra o caminho entre dois nós com o menor número de saltos. Para um melhor
desempenho, foi usada uma lista duplamente ligada para a implementação da fila de espera deste
algoritmo. Deste modo, tanto as operações de \emph{push} como \emph{pop} podem ser executadas em
tempo constante. Tal como na procura em profundidade, o algoritmo não expande nós que ultrapassem o
limite de combustível do veículo a realizar a procura.

\subsection{Procura de custo uniforme / Algoritmo de Dijkstra}

Este algoritmo encontra o caminho com menor custo entre dois nós. Para a implementação da fila de
prioridades necessária para este algoritmo, foi utilizado um \emph{heap} binário, que apresenta
melhor desempenho do que listas. Tal como os outros algoritmos, não são expandidos nós fora do
alcance do combustível do veículo a realizar a procura, diminuindo o número de nós visitados quando
não existe um caminho que o veículo seja capaz de realizar.

\subsection{Procura gulosa}

Este algoritmo é muito semelhante à procura em profundidade, com a diferença de que a ordem de
expansão dos vizinhos de um nó é determinada por uma heurística. Tal como na implementação da
procura em profundidade, o algoritmo foi implementado iterativamente, e também não expande nós
fora do alcance do combustível do veículo a realizar a procura. Uma outra otimização, exclusiva à
procura gulosa, relaciona-se com a heurística de distância cartesiana. Como os valores da
heurística apenas são utilizados para comparação entre si, visto que a raiz quadrada é uma função
monótona crescente, o seu cálculo não é necessário, melhorando o desempenho do algoritmo:

$$
    dx_1^2 + dy_1^2 < dx_2^2 + dy_2^2
    \Rightarrow
    \sqrt{dx_1^2 + dy_1^2} < \sqrt{dx_2^2 + dy_2^2}
$$

\subsection{A*}

A única diferença entre este algoritmo e o algoritmo de Dijkstra é a ordem dos nós na fila de
espera, que passam a estar ordenados pela soma da sua distância à origem da procura com a sua
heurística. Quando a heurística é cartesiana, já não é possível evitar o cálculo das raízes
quadradas como na pesquisa gulosa, visto que é necessário que a heurística não sobreestime o custo
entre dois nós caso se deseje que o algoritmo devolva a solução ótima de um problema de procura
\cite{aima}.

\section{Algoritmo para empacotamento}

Para o envio de recursos para um local, é necessário distribuí-los por veículos, Surge um problema
de empacotamento, onde se procura distribuir vários produtos, cada um com um peso, por vários
veículos, cada um com um limite de peso e um custo de envio, procurando maximizar-se o peso enviado,
enquanto se minimiza o custo de envio dos veículos.

Na aplicação desenvolvida, este problema é resolvido com um algoritmo genético. Um indivíduo, que
correspondente a uma distribuição dos produtos pelos veículos, é constituído por tantos genes
quantos produtos. Cada gene é um número inteiro, e corresponde ao veículo em que o produto deve ser
colocado. Segue-se, abaixo, o exemplo de um indivíduo, onde todos os produtos são colocados no
veículo 0, com exceção do 3º produto, que é colocado no veículo 1.

\begin{table}[H]
    \begin{center}
        \begin{tabular}{|c|c|c|c|c|}
            \hline 0 & 0 & 1 & 0 & 0 \\ \hline
        \end{tabular}

        \caption{Exemplo um indivíduo no algoritmo genético utilizado para empacotamento.}
    \end{center}
\end{table}

A função de \emph{fitness} utilizada devolve 0 caso pelo menos um dos veículos ultrapasse o seu
limite de preço. Quando esta condição não é violada, procura-se, por esta ordem, maximizar o
peso enviado, minimizar o custo dos veículos enviados, e minimizar o número de veículos enviados.
Para ordenar estes valores, garantiu-se, através de multiplicações, que estes estavam em diferentes
ordens de grandeza:

$$
\mathcal{F}(X) =
\begin{cases}
    0
        ,& \text{se há veículos sobrecarregados} \\
    \text{Peso}(X) \times 10^6 - \text{Custo}(X) - \text{N}_\text{veículos}(X)
        ,& \text{caso contrário}
\end{cases}
$$

A operação de cruzamento é simples: é escolhido um índice onde os cromossomas dos pais são
divididos, e geram-se dois filhos, cada um com uma primeira parte do cromossoma de um dos pais e com
uma segunda parte do outro. A função de mutação, no entanto, já é mais complexa. Uma possível
mutação é a alteração do veículo no qual um produto é colocado. No entanto, para evitar que o
algoritmo convirja para colocar todos os produtos num veículo de maior custo quando um de menor
custo existe, uma possível mutação é a alteração de veículo de todos os produtos no mesmo veículo.

\section{Conclusão}

\section{Bibliografia}
\def\refname{}
\vspace{-1.5cm}
\begin{thebibliography}{9}
    \bibitem{aima} S. Russel and P. Norvig, \emph{Artificial Intelligence -- A Modern Approach},
        4th ed. USA: Pearson, 2021.
\end{thebibliography}

\end{document}
